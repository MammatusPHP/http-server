<?php declare(strict_types=1);

// phpcs:disable
namespace Mammatus\Http\Server\Generated;

use Mammatus\Http\Server\WebSockets\Broadcaster;
use Mammatus\Http\Server\WebSockets\Income;
use Mammatus\Http\Server\WebSockets\RpcInput;
use Mammatus\LifeCycleEvents\Initialize;
use Mammatus\LifeCycleEvents\Shutdown;
use Psr\Container\ContainerInterface;
use Psr\Log\LoggerInterface;
use React\EventLoop\LoopInterface;
use React\Promise\PromiseInterface;
use ReactParallel\Factory;
use ReactParallel\Pool\Worker\Worker as WorkerPool;
use Thruway\Peer\Client;
use Thruway\ClientSession;
use Thruway\Peer\Router;
use WyriHaximus\Broadcast\Contracts\Listener;
use WyriHaximus\Metrics\Label;
use WyriHaximus\Metrics\Label\Name;
use WyriHaximus\Metrics\Registry;

/**
 * This class is generated by mammatus/http-server
 */
final class RouterFactory_{{ server.vhost().nameSanitized() }} implements Listener
{
    private LoopInterface $loop;
    private ?Router $router = null;
    private LoggerInterface $logger;
    private Registry $registry;
    private ContainerInterface $container;
    {% for realm in server.realms() %}
    {% for bus in realm.busses() %}
    private ?WorkerPool $workerPool_{{ server.vhost().nameSanitized() }}_{{ bus }} = null;
    {% endfor %}
    {% endfor %}

    public function __construct(LoopInterface $loop, LoggerInterface $logger, Registry $registry, ContainerInterface $container)
    {
        $this->loop = $loop;
        $this->logger = $logger;
        $this->registry = $registry;
        $this->container = $container;
    }

    private function setUp()
    {
        if ($this->router instanceof Router) {
            return;
        }

        $this->router = new Router($this->loop);
        $rpFactory = $this->container->get(Factory::class);
        {% for realm in server.realms() %}
        {% for bus in realm.busses() %}
        $this->workerPool_{{ server.vhost().nameSanitized() }}_{{ bus }} = new WorkerPool(
            $rpFactory,
            $this->container->get(WebSocketWorkerFactory_{{ server.vhost().nameSanitized() }}_{{ bus }}::class),
            (int) '13'
        );
        {% endfor %}
        {% endfor %}

        {% for realm in server.realms() %}
        $this->registry->counter(
            'vhost_realm_rpcs',
            'Registered RPC\'s',
            new Name('vhost'),
            new Name('realm'),
        )->counter(
            new Label('vhost', '{{ server.vhost().name() }}'),
            new Label('realm', '{{ realm.name() }}'),
        )->incrBy({{ realm.rpcs()|length }});
        $this->registry->counter(
            'vhost_realm_subscriptions',
            'Registered subscriptions',
            new Name('vhost'),
            new Name('realm'),
        )->counter(
            new Label('vhost', '{{ server.vhost().name() }}'),
            new Label('realm', '{{ realm.name() }}'),
        )->incrBy({{ realm.subscriptions()|length }});
        $internalClient_{{ realm.nameSanitized() }} = new Client('{{ realm.name() }}', $this->loop);
        $internalClient_{{ realm.nameSanitized() }}->on('open', function (ClientSession $session) use ($workerPools): void {
            {% for rpc in realm.rpcs() %}
            $session->register('{{ rpc.name() }}', fn (array $args): PromiseInterface => $this->handleRpc_{{ server.vhost().nameSanitized() }}_{{ rpc.bus() }}_{{ rpc.nameSanitized() }}($args));
            $this->logger->debug('Registered RPC "{{ rpc.name() }}" on realm "{{ realm.name() }}" for bus "{{ rpc.bus() }}" on the "{{ server.vhost().name() }}" vhost');
            {% endfor %}
            {% if realm.broadcasts()|length > 0 %}
            $broadcaster_{{ realm.nameSanitized() }} = new Broadcaster($session);
            {% endif %}
            {% for broadcast in realm.broadcasts() %}
            $this->container->get(\{{ broadcast.class() }}::class)->broadcast($broadcaster_{{ realm.nameSanitized() }});
            {% endfor %}
            {% for subscription in realm.subscriptions() %}
            $session->subscribe('{{ subscription.name() }}', fn (array $args): PromiseInterface => $this->handleSubscription_{{ server.vhost().nameSanitized() }}_{{ subscription.bus() }}_{{ subscription.nameSanitized() }}($args));
            {% endfor %}
        });
        $internalClient_{{ realm.nameSanitized() }}->on('close', function (ClientSession $session): void {
            {% for rpc in realm.rpcs() %}
            $session->unregister('{{ rpc.name() }}');
            $this->logger->debug('Unregistered RPC "{{ rpc.name() }}" on realm "{{ realm.name() }}" for bus "{{ rpc.bus() }}" on the "{{ server.vhost().name() }}" vhost');
            {% endfor %}
        });
        $this->router->addInternalClient($internalClient_{{ realm.nameSanitized() }});
        {% endfor %}
    }

    public function router(): Router
    {
        $this->setUp();

        return $this->router;
    }

    public function start(Initialize $event): void
    {
        $this->setUp();

        $this->logger->debug('Starting websocket server: {{ server.vhost().name() }}');
        $this->router->start(false);
        $this->logger->debug('Started websocket server: {{ server.vhost().name() }}');
    }

    public function stop(Shutdown $event): void
    {
        $this->logger->debug('Stopping websocket server: {{ server.vhost().name() }}');
        $this->router->stop();
        $this->logger->debug('Stopped websocket server: {{ server.vhost().name() }}');
    }
    {% for realm in server.realms() %}
    {% for rpc in realm.rpcs() %}
    private function handleRpc_{{ server.vhost().nameSanitized() }}_{{ rpc.busSanitized() }}_{{ rpc.nameSanitized() }}(array $args): PromiseInterface
    {
        $this->registry->counter(
            'vhost_realm_rpc_call',
            'RPC calls',
            new Name('vhost'),
            new Name('realm'),
            new Name('topic'),
        )->counter(
            new Label('vhost', '{{ server.vhost().name() }}'),
            new Label('realm', '{{ realm.name() }}'),
            new Label('topic', '{{ rpc.name() }}'),
        )->incr();

        return $this->workerPool_{{ server.vhost().nameSanitized() }}_{{ rpc.busSanitized() }}->perform(new Income(\{{ rpc.command() }}::fromInput(new RpcInput(
            {% if rpc.transformer() is not null %}
            \{{ rpc.transformer() }}::transform(
            {% endif %}
                $args[0] ?? null
            {% if rpc.transformer() is not null %}
            )
            {% endif %}
        ))));
    }
    {% endfor %}
    {% for subscription in realm.subscriptions() %}
    private function handleSubscription_{{ server.vhost().nameSanitized() }}_{{ subscription.busSanitized() }}_{{ subscription.nameSanitized() }}(array $args): PromiseInterface
    {
        $this->registry->counter(
            'vhost_realm_subscription_call',
            'Subscription calls',
            new Name('vhost'),
            new Name('realm'),
            new Name('topic'),
        )->counter(
            new Label('vhost', '{{ server.vhost().name() }}'),
            new Label('realm', '{{ realm.name() }}'),
            new Label('topic', '{{ subscription.name() }}'),
        )->incr();

        return $this->workerPool_{{ server.vhost().nameSanitized() }}_{{ subscription.busSanitized() }}->perform(new Income(\{{ subscription.command() }}::fromInput(new RpcInput(
            {% if subscription.transformer() is not null %}
            \{{ subscription.transformer() }}::transform(
            {% endif %}
                $args[0] ?? null
            {% if subscription.transformer() is not null %}
            )
            {% endif %}
        ))));
    }
    {% endfor %}
    {% endfor %}
}
// phpcs:enable
