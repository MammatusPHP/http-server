<?php declare(strict_types=1);

namespace Mammatus\Http\Server\Generated\Server;

/**
 * This class is generated by mammatus/http-server, do not edit manually.
 * Or do, I'm not your parent, they will be overwritten next composer install/update ¯\_(ツ)_/¯.
 */
final readonly class {{ vhost.server_class_name }} implements \Mammatus\Groups\Contracts\LifeCycleHandler
{
    public const string NAME = '{{ vhost.vhost.name }}';

    private \React\Socket\SocketServer $server;

    public function __construct(
        private \{{ vhost.vhost.class }} $vhost,
        private \Psr\Log\LoggerInterface $logger,
    ) {
        $this->server = new \React\Socket\SocketServer('0.0.0.0:{{ vhost.vhost.port }}');
    }

    public static function group(): string
    {
        return '{{ vhost.vhost.group.name }}';
    }

    public function start(): void
    {
        $this->logger->debug('Starting server: {serverName}', ['serverName' => self::NAME]);
        $dispatcher = \FastRoute\FastRoute::recommendedSettings(static function(\FastRoute\ConfigureRoutes $routes): void {
            {% for handler in vhost.handlers -%}
            $routes->addRoute(
                '{{ handler.route.httpMethod.value }}',
                '{{ handler.route.path }}',
                {% if handler.static -%}
                '\{{ handler.class }}::{{ handler.method }}',
                {% else -%}
                'get_all_users_handler',
                {% endif %}
            );
            {% endfor %}
        }, '{{ vhost.vhost.name }}')->dispatcher();
        /** @phpstan-ignore argument.type */
        $http = new \React\Http\HttpServer(...[
            \React\Async\async(function (\Psr\Http\Message\ServerRequestInterface $request, callable $next): \Psr\Http\Message\ResponseInterface {
                /** @var callable(\Psr\Http\Message\ServerRequestInterface): \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> $next */
                $response = \React\Async\await($next($request));

                $this->logger->info(
                    '[{serverName}] {httpMethod} {path} {statusCode}',
                    [
                        'serverName' => self::NAME,
                        'httpMethod' => $request->getMethod(),
                        'path' => $request->getUri()->getPath(),
                        'statusCode' => $response->getStatusCode(),
                    ],
                );

                return $response;
            }),
            //new \WyriHaximus\React\Http\Middleware\ResumeResponseBodyMiddleware(),
            new \React\Http\Middleware\RequestBodyBufferMiddleware(),
            new \React\Http\Middleware\RequestBodyParserMiddleware(),
            //new \WyriHaximus\React\Http\Middleware\CustomRequestBodyParsers(),
            ...$this->vhost->middleware(), // @TODO: PSR-15 wrapping
            {% if vhost.vhost.webrootPath != '' -%}
            new \WyriHaximus\React\Http\Middleware\WebrootPreloadMiddleware(
                '{{ vhost.vhost.webrootPath }}',
                $this->logger,
                new \React\Cache\ArrayCache(),
            ),
            {% endif -%}
            \React\Async\async(function (\Psr\Http\Message\ServerRequestInterface $request) use ($dispatcher): \Psr\Http\Message\ResponseInterface {
                $routeInfo = $dispatcher->dispatch($request->getMethod(), $request->getUri()->getPath());
                /** @phpstan-ignore return.type */
                return match ($routeInfo::class) {
                    \FastRoute\Dispatcher\Result\NotMatched::class => \React\Http\Message\Response::plaintext(
                            "Not found!\n"
                        )->withStatus(404),
                    \FastRoute\Dispatcher\Result\MethodNotAllowed::class => \React\Http\Message\Response::plaintext(
                            "Method not allowed!\n"
                        )->withStatus(405),
                    /** @phpstan-ignore callable.nonCallable */
                    \FastRoute\Dispatcher\Result\Matched::class => ($routeInfo->handler)($routeInfo->variables),
                };
            }),
        ]);
        $http->listen($this->server);
        $http->on('error', function (\Throwable $error): void {
            /** @phpstan-ignore psr3.interpolated */
            $this->logger->error($error->getMessage(), ['exception' => $error]);
        });
        $this->logger->debug('Started server: {serverName}', ['serverName' => self::NAME]);
    }

    public function stop(): void
    {
        $this->logger->debug('Stopping server: {serverName}', ['serverName' => self::NAME]);
        $this->server->close();
        $this->logger->debug('Stopped server: {serverName}', ['serverName' => self::NAME]);
    }
}
